![BrightCoders Logo](img/logo.png)

- [Cifrado de Vigenere](#cifrado-de-vigenere)
- [Objetivo](#objetivo)
- [Instrucciones](#instrucciones)
- [Entregables](#entregables)
- [Indicadores de cumplimiento](#indicadores-de-cumplimiento)
- [Flujo de trabajo](#flujo-de-trabajo)
  - [D√≠a 1](#d√≠a-1)
  - [D√≠a 2](#d√≠a-2)
  - [D√≠a 3](#d√≠a-3)
  - [D√≠a 4 - 5](#d√≠a-4---5)
- [Tecnolog√≠as](#tecnolog√≠as)
- [Requerimientos funcionales](#requerimientos-funcionales)
- [Requerimientos no funcionales](#requerimientos-no-funcionales)
- [Recursos](#recursos)

# üöÄ Cifrado de Vigenere

- **Organizaci√≥n.**  [Individual](https://github.com/BrightCoders-Institute/handbook/wiki/Actividades#actividades-individuales-as%C3%ADncronas)
- **Modo.** [S√≠ncrono](https://github.com/BrightCoders-Institute/handbook/wiki/Actividades#actividades-individuales-as%C3%ADncronas)
- **Estrategia.** Programaci√≥n individual
- **Duraci√≥n.** 5 d√≠as
- **Dedicaci√≥n.** 1.5 horas diarias (7.5 horas total)

# üéØ Objetivo

Esta actividad tiene como objetivos:

- **Practicar la sem√°ntica y sintaxis de Ruby:** Desarrollar habilidades s√≥lidas en el uso correcto de la sintaxis y las convenciones de nomenclatura de Ruby, as√≠ como comprender y aplicar adecuadamente los conceptos sem√°nticos del lenguaje.
- **Utilizar RuboCop para mejorar la calidad del c√≥digo Ruby:** Familiarizarse con la herramienta RuboCop y utilizarla como gu√≠a para garantizar la consistencia y legibilidad del c√≥digo, siguiendo las mejores pr√°cticas y convenciones de estilo de Ruby.
- **Aplicar principios de programaci√≥n orientada a objetos en Ruby:** Comprender y aplicar los conceptos fundamentales de la programaci√≥n orientada a objetos (POO) en Ruby, como encapsulaci√≥n, herencia, polimorfismo y abstracci√≥n, para crear c√≥digo modular, reutilizable y f√°cil de mantener.
- **Emplear el polimorfismo como una soluci√≥n mejor a las banderas booleanas:** Practicar el uso del polimorfismo en situaciones donde se utilizan banderas booleanas, aprovechando la capacidad de los objetos de comportarse de diferentes formas seg√∫n su tipo, lo que promueve un dise√±o m√°s limpio, extensible y f√°cil de entender.
- **Practicar el desarrollo basado en pruebas con Ruby, RSpec y/o MiniTest:** Adquirir experiencia en el desarrollo de pruebas unitarias y funcionales utilizando frameworks populares como RSpec y/o MiniTest, para garantizar la calidad y robustez del c√≥digo, as√≠ como facilitar la detecci√≥n temprana de errores y el mantenimiento a largo plazo.
- **Introducir los principios SOLID:** Familiarizarse con los principios SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) y aplicarlos en el dise√±o y desarrollo de software, buscando lograr un c√≥digo m√°s modular, flexible y f√°cil de mantener.

# üìã Instrucciones

- Utilizando Ruby, se desarrollar√° una soluci√≥n completa para el algoritmo que se explica en la secci√≥n de __requerimientos funcionales__.
- Se utilizar√° RuboCop para garantizar la consistencia y legibilidad del c√≥digo, siguiendo las mejores pr√°cticas y convenciones de estilo de Ruby.
- La soluci√≥n deber√° seguir el enfoque orientado a objetos.
- Se pondr√° en pr√°ctica el concepto de desarrollo basado en pruebas utilizando RSpec o MiniTest.
- Se aplicar√° el concepto de commits significativos.

# üì• Entregables

- C√≥digo Ruby funcional y completo en la rama principal de este repositorio.
- Implementaci√≥n orientada a objetos que refleje los principios de la programaci√≥n orientada a objetos en Ruby.
- Reemplazo de banderas booleanas por polimorfismo en situaciones pertinentes, mejorando el dise√±o del c√≥digo.
- Archivo de configuraci√≥n de RuboCop aplicado al proyecto para garantizar la calidad del c√≥digo.
- Conjunto completo de pruebas unitarias y funcionales desarrolladas con RSpec y/o MiniTest para verificar el correcto funcionamiento del c√≥digo.
- Archivo README.md actualizado con las instrucciones de ejecuci√≥n y cualquier otra informaci√≥n relevante.

# ‚úÖ Indicadores de cumplimiento

1. Sintaxis y sem√°ntica de Ruby:
   - El c√≥digo debe estar escrito utilizando la sintaxis correcta de Ruby.
   - Se deben utilizar las convenciones de nomenclatura adecuadas de Ruby.

2. Uso de RuboCop:
   - Se debe utilizar RuboCop como herramienta de an√°lisis est√°tico para mejorar la calidad del c√≥digo Ruby.

3. Programaci√≥n orientada a objetos:
   - Deben aplicarse los conceptos fundamentales de la programaci√≥n orientada a objetos, como encapsulaci√≥n, herencia, polimorfismo y abstracci√≥n.
   - El c√≥digo debe ser modular, reutilizable y f√°cil de mantener.

4. Uso de polimorfismo en lugar de banderas booleanas:
   - Deben identificarse situaciones en las que se utilizan banderas booleanas y reemplazarlas por polimorfismo.

5. Desarrollo basado en pruebas:
   - Se deben desarrollar pruebas unitarias y funcionales utilizando RSpec y/o MiniTest.
   - Las pruebas deben garantizar la calidad y robustez del c√≥digo.

6. Aplicaci√≥n de los principios SOLID:
   - Deben aplicarse los principios SOLID (Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, Dependency Inversion) en el dise√±o y desarrollo del software.
   - El c√≥digo debe ser modular, flexible y f√°cil de mantener.

# üí° Flujo de trabajo

A continuaci√≥n se presenta un flujo de trabajo sugerido para el desarrollo del algoritmo. Si se decide seguir otro enfoque, es v√°lido siempre y cuando se logre el mismo resultado:

## D√≠a 1

- Comienza a codificar la soluci√≥n del algoritmo centr√°ndote en establecer una base s√≥lida. Utiliza el enfoque orientado a objetos y recuerda que este ejercicio es principalmente para aprender y familiarizarte con Ruby.

## D√≠a 2

- Contin√∫a desarrollando la soluci√≥n, esta vez reemplazando las banderas booleanas por polimorfismo en situaciones relevantes. Esto mejorar√° el dise√±o del c√≥digo y te permitir√° explorar las capacidades flexibles de Ruby.

## D√≠a 3

- Sigue avanzando en el desarrollo de la soluci√≥n y aseg√∫rate de incorporar el uso de RuboCop. Utiliza esta herramienta para mantener la consistencia y la legibilidad del c√≥digo, siguiendo las mejores pr√°cticas y convenciones de estilo de Ruby.
- Contin√∫a aprendiendo y experimentando con Ruby. Recuerda que no es necesario completar la soluci√≥n en este momento, ya que el objetivo principal es el aprendizaje.

## D√≠a 4 - 5

- Lleg√≥ el momento de finalizar la soluci√≥n. Aseg√∫rate de incorporar pruebas unitarias y funcionales utilizando frameworks populares como RSpec y/o MiniTest. Estas pruebas garantizar√°n la calidad y robustez del c√≥digo, permitiendo la detecci√≥n temprana de errores y facilitando el mantenimiento a largo plazo.
- Enf√≥cate en escribir m√©todos peque√±os y con un solo prop√≥sito. Esto mejorar√° la legibilidad y el mantenimiento del c√≥digo.
- Adem√°s, aprovecha este tiempo para estudiar y aplicar los principios SOLID en tu c√≥digo, buscando lograr un dise√±o modular y flexible.

Recuerda que el objetivo principal de este flujo de trabajo es aprender y mejorar tus habilidades en Ruby. Lo importante es el proceso de aprendizaje y la adquisici√≥n de nuevos conocimientos.

# üõ† Tecnolog√≠as

- Ruby
- Rubocop
- [RSpec](https://rspec.info/)
- [Minitest](https://github.com/minitest/minitest)

# üßëüèª‚Äçüíª Requerimientos funcionales

El cifrado de Vigen√®re es un tipo de cifrado polialfab√©tico, lo que significa que utiliza diferentes alfabetos para cifrar un mensaje. El algoritmo se basa en una tabla conocida como la tabla de Vigen√®re o tabla de coincidencias, que es esencial para su implementaci√≥n.

Aqu√≠ est√° el paso a paso del algoritmo:

1. Primero, necesitas tener la clave de cifrado. La clave es una palabra o una frase que se utilizar√° para cifrar el mensaje. Por ejemplo, la clave podr√≠a ser "SECRETO".

2. Luego, convierte el mensaje original y la clave a valores num√©ricos seg√∫n la posici√≥n de las letras en el alfabeto. Por ejemplo, A=0, B=1, C=2, y as√≠ sucesivamente. Si el mensaje original es "HOLA" y la clave es "SECRETO", se convierten a n√∫meros de la siguiente manera:
   - Mensaje original: H=7, O=14, L=11, A=0
   - Clave: S=18, E=4, C=2, R=17, E=4, T=19, O=14

3. Ahora, se debe repetir la clave para que tenga la misma longitud que el mensaje original. En este caso, la clave "SECRETO" se repetir√° hasta que tenga la longitud del mensaje original. Por lo tanto, la clave repetida ser√≠a: "SECRETOSE".

4. A continuaci√≥n, sumamos el valor num√©rico de cada letra del mensaje original con el valor num√©rico correspondiente de la clave repetida, utilizando aritm√©tica modular. Para esto, utilizamos la tabla de Vigen√®re.

   - Para cifrar el primer car√°cter del mensaje original "H" (valor num√©rico 7) con el primer car√°cter de la clave "S" (valor num√©rico 18), encontramos la intersecci√≥n en la tabla de Vigen√®re. El valor cifrado ser√≠a "Z" (valor num√©rico 25). As√≠ sucesivamente, se aplica este proceso para cada letra del mensaje original.

5. Finalmente, convertimos los valores num√©ricos cifrados en letras nuevamente, utilizando la tabla de Vigen√®re inversa.

   - Por ejemplo, el valor num√©rico cifrado "Z" (valor num√©rico 25) se convierte en "A". As√≠, convertimos todos los valores num√©ricos cifrados nuevamente a letras.

6. El resultado final es el mensaje cifrado, que se obtiene al combinar las letras obtenidas en el paso anterior. En este caso, si ciframos el mensaje original "HOLA" con la clave "SECRETO", el mensaje cifrado resultante ser√≠a "ZURW".

Este es el proceso b√°sico del algoritmo de cifrado de Vigen√®re. Para implementarlo en un programa, necesitar√≠as funciones para convertir letras en valores num√©ricos y viceversa, as√≠ como la tabla de Vigen√®re para encontrar las coincidencias. Puedes utilizar ciclos y operaciones matem√°ticas para realizar las sumas y c√°lculos necesarios.

Recuerda que el cifrado de Vigen√®re es un cifrado cl√°sico y no se considera seguro en la actualidad. Sin embargo, es un buen ejercicio

<img src="img/cuadro_vigenere.png"  height="600">

Tabla de Vigen√®re

# üö® Requerimientos no funcionales

- Calidad:
  - Aplicar el estilo de c√≥digo definido por la comunidad, utilizando RuboCop como herramienta de apoyo.
  - Incluir pruebas unitarias para garantizar la calidad del c√≥digo.

- Desempe√±o y escalabilidad:
  - Permitir la ejecuci√≥n desde la l√≠nea de comandos y mostrar la salida en la consola de manera eficiente y r√°pida.

- C√≥digo fuente:
  - Desarrollar una soluci√≥n orientada a objetos, siguiendo los principios de la programaci√≥n orientada a objetos (POO).
  - Escribir m√©todos peque√±os y con un solo prop√≥sito para mejorar la legibilidad y el mantenimiento del c√≥digo.
  - Aplicar los principios SOLID para lograr un dise√±o modular, flexible y de f√°cil extensibilidad.

# üìö Recursos

- [Desarrollo Basado en Pruebas](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/ruby-on-rails/desarrollo-basado-en-pruebas)
- [RuboCop](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/ruby-on-rails/rubocop)
- [Principios SOLID y Polimorfismo](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/ruby-on-rails/solid-and-polimorfismo)
- [Git & Github](https://brightcoders-2.gitbook.io/brightcoders-handbook/recursos/git-and-github/git-and-github)
